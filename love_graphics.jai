// This file was generated by generate_bindings.lua

Canvas :: #type,distinct lua.Ref;
Drawable :: #type,distinct lua.Ref;
Font :: #type,distinct lua.Ref;
Image :: #type,distinct lua.Ref;
Mesh :: #type,distinct lua.Ref;
ParticleSystem :: #type,distinct lua.Ref;
Quad :: #type,distinct lua.Ref;
Shader :: #type,distinct lua.Ref;
SpriteBatch :: #type,distinct lua.Ref;
Text :: #type,distinct lua.Ref;
Texture :: #type,distinct lua.Ref;
Video :: #type,distinct lua.Ref;

AlignMode :: enum {
	Center; // center
	Left; // left
	Right; // right
	Justify; // justify
}
AlignModeMap :: string.[ "center", "left", "right", "justify" ];

ArcType :: enum {
	Pie; // pie
	Open; // open
	Closed; // closed
}
ArcTypeMap :: string.[ "pie", "open", "closed" ];

AreaSpreadDistribution :: enum {
	Uniform; // uniform
	Normal; // normal
	Ellipse; // ellipse
	BorderEllipse; // borderellipse
	BorderRectangle; // borderrectangle
	None; // none
}
AreaSpreadDistributionMap :: string.[ "uniform", "normal", "ellipse", "borderellipse", "borderrectangle", "none" ];

BlendAlphaMode :: enum {
	AlphaMultiply; // alphamultiply
	Premultiplied; // premultiplied
}
BlendAlphaModeMap :: string.[ "alphamultiply", "premultiplied" ];

BlendMode :: enum {
	Alpha; // alpha
	Replace; // replace
	Screen; // screen
	Add; // add
	Subtract; // subtract
	Multiply; // multiply
	Lighten; // lighten
	Darken; // darken
	Additive; // additive
	Subtractive; // subtractive
	Multiplicative; // multiplicative
	Premultiplied; // premultiplied
}
BlendModeMap :: string.[ "alpha", "replace", "screen", "add", "subtract", "multiply", "lighten", "darken", "additive", "subtractive", "multiplicative", "premultiplied" ];

CompareMode :: enum {
	Equal; // equal
	NotEqual; // notequal
	Less; // less
	LEqual; // lequal
	GEqual; // gequal
	Greater; // greater
	Never; // never
	Always; // always
}
CompareModeMap :: string.[ "equal", "notequal", "less", "lequal", "gequal", "greater", "never", "always" ];

CullMode :: enum {
	Back; // back
	Front; // front
	None; // none
}
CullModeMap :: string.[ "back", "front", "none" ];

DrawMode :: enum {
	Fill; // fill
	Line; // line
}
DrawModeMap :: string.[ "fill", "line" ];

FilterMode :: enum {
	Linear; // linear
	Nearest; // nearest
}
FilterModeMap :: string.[ "linear", "nearest" ];

GraphicsFeature :: enum {
	ClampZero; // clampzero
	Lighten; // lighten
	MultiCanvasFormats; // multicanvasformats
	Glsl3; // glsl3
	Instancing; // instancing
	FullNPOT; // fullnpot
	PixelShaderHighP; // pixelshaderhighp
	ShaderDerivatives; // shaderderivatives
}
GraphicsFeatureMap :: string.[ "clampzero", "lighten", "multicanvasformats", "glsl3", "instancing", "fullnpot", "pixelshaderhighp", "shaderderivatives" ];

GraphicsLimit :: enum {
	PointSize; // pointsize
	TextureSize; // texturesize
	MultiCanvas; // multicanvas
	CanvasMSAA; // canvasmsaa
	TextureLayers; // texturelayers
	VolumeTextureZize; // volumetexturesize
	CubeTextureZize; // cubetexturesize
	Anisotropy; // anisotropy
}
GraphicsLimitMap :: string.[ "pointsize", "texturesize", "multicanvas", "canvasmsaa", "texturelayers", "volumetexturesize", "cubetexturesize", "anisotropy" ];

IndexDataType :: enum {
	Uint16; // uint16
	Uint32; // uint32
}
IndexDataTypeMap :: string.[ "uint16", "uint32" ];

LineJoin :: enum {
	Miter; // miter
	None; // none
	Bevel; // bevel
}
LineJoinMap :: string.[ "miter", "none", "bevel" ];

LineStyle :: enum {
	Rough; // rough
	Smooth; // smooth
}
LineStyleMap :: string.[ "rough", "smooth" ];

MeshDrawMode :: enum {
	Fan; // fan
	Strip; // strip
	Triangles; // triangles
	Points; // points
}
MeshDrawModeMap :: string.[ "fan", "strip", "triangles", "points" ];

MipmapMode :: enum {
	None; // none
	Auto; // auto
	Manual; // manual
}
MipmapModeMap :: string.[ "none", "auto", "manual" ];

ParticleInsertMode :: enum {
	Top; // top
	Bottom; // bottom
	Random; // random
}
ParticleInsertModeMap :: string.[ "top", "bottom", "random" ];

SpriteBatchUsage :: enum {
	Dynamic; // dynamic
	Static; // static
	Stream; // stream
}
SpriteBatchUsageMap :: string.[ "dynamic", "static", "stream" ];

StackType :: enum {
	Transform; // transform
	All; // all
}
StackTypeMap :: string.[ "transform", "all" ];

StencilAction :: enum {
	Replace; // replace
	Increment; // increment
	Decrement; // decrement
	Incrementwrap; // incrementwrap
	Decrementwrap; // decrementwrap
	Invert; // invert
}
StencilActionMap :: string.[ "replace", "increment", "decrement", "incrementwrap", "decrementwrap", "invert" ];

TextureType :: enum {
	_2D; // 2d
	Array; // array
	Cube; // cube
	Volume; // volume
}
TextureTypeMap :: string.[ "2d", "array", "cube", "volume" ];

VertexAttributeStep :: enum {
	PerVertex; // pervertex
	PerInstance; // perinstance
}
VertexAttributeStepMap :: string.[ "pervertex", "perinstance" ];

VertexWinding :: enum {
	CW; // cw
	CCW; // ccw
}
VertexWindingMap :: string.[ "cw", "ccw" ];

WrapMode :: enum {
	Clamp; // clamp
	Repeat; // repeat
	MirroredRepeat; // mirroredrepeat
	ClampZero; // clampzero
}
WrapModeMap :: string.[ "clamp", "repeat", "mirroredrepeat", "clampzero" ];


// Applies the given Transform object to the current coordinate transformation.
love_graphics_applyTransform :: (transform: Transform) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "applyTransform");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.rawgeti(L, lua.LUA_REGISTRYINDEX, xx transform);
	lua.call(L, 1, 0);
}
// Draws a filled or unfilled arc at position (x, y). The arc is drawn from angle1 to angle2 in radians. The segments parameter determines how many segments are used to draw the arc. The more segments, the smoother the edge.
love_graphics_arc :: (drawmode: *u8, x: lua.Number, y: lua.Number, radius: lua.Number, angle1: lua.Number, angle2: lua.Number, segments: lua.Number) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "arc");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushstring(L, drawmode);
	lua.pushnumber(L, x);
	lua.pushnumber(L, y);
	lua.pushnumber(L, radius);
	lua.pushnumber(L, angle1);
	lua.pushnumber(L, angle2);
	lua.pushnumber(L, segments);
	lua.call(L, 7, 0);
}
// Draws a filled or unfilled arc at position (x, y). The arc is drawn from angle1 to angle2 in radians. The segments parameter determines how many segments are used to draw the arc. The more segments, the smoother the edge.
love_graphics_arc :: (drawmode: *u8, arctype: *u8, x: lua.Number, y: lua.Number, radius: lua.Number, angle1: lua.Number, angle2: lua.Number, segments: lua.Number) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "arc");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushstring(L, drawmode);
	lua.pushstring(L, arctype);
	lua.pushnumber(L, x);
	lua.pushnumber(L, y);
	lua.pushnumber(L, radius);
	lua.pushnumber(L, angle1);
	lua.pushnumber(L, angle2);
	lua.pushnumber(L, segments);
	lua.call(L, 8, 0);
}
// Creates a screenshot once the current frame is done (after love.draw has finished).
love_graphics_captureScreenshot :: (filename: *u8) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "captureScreenshot");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushstring(L, filename);
	lua.call(L, 1, 0);
}
// Creates a screenshot once the current frame is done (after love.draw has finished).
love_graphics_captureScreenshot :: (callback: *void) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "captureScreenshot");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushcclosure(L, callback, 0);
	lua.call(L, 1, 0);
}
// Creates a screenshot once the current frame is done (after love.draw has finished).
love_graphics_captureScreenshot :: (channel: Channel) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "captureScreenshot");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.rawgeti(L, lua.LUA_REGISTRYINDEX, xx channel);
	lua.call(L, 1, 0);
}
// Draws a circle.
love_graphics_circle :: (mode: *u8, x: lua.Number, y: lua.Number, radius: lua.Number) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "circle");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushstring(L, mode);
	lua.pushnumber(L, x);
	lua.pushnumber(L, y);
	lua.pushnumber(L, radius);
	lua.call(L, 4, 0);
}
// Draws a circle.
love_graphics_circle :: (mode: *u8, x: lua.Number, y: lua.Number, radius: lua.Number, segments: lua.Number) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "circle");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushstring(L, mode);
	lua.pushnumber(L, x);
	lua.pushnumber(L, y);
	lua.pushnumber(L, radius);
	lua.pushnumber(L, segments);
	lua.call(L, 5, 0);
}
// Clears the screen or active Canvas to the specified color.
love_graphics_clear :: () #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "clear");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.call(L, 0, 0);
}
// Clears the screen or active Canvas to the specified color.
love_graphics_clear :: (r: lua.Number, g: lua.Number, b: lua.Number, a: lua.Number, clearstencil: s32, cleardepth: s32) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "clear");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushnumber(L, r);
	lua.pushnumber(L, g);
	lua.pushnumber(L, b);
	lua.pushnumber(L, a);
	lua.pushboolean(L, clearstencil);
	lua.pushboolean(L, cleardepth);
	lua.call(L, 6, 0);
}
// Clears the screen or active Canvas to the specified color.
love_graphics_clear :: (color: lua.Table) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "clear");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.createtable(L, 0, 0);
	lua.call(L, 1, 0);
}
// Clears the screen or active Canvas to the specified color.
love_graphics_clear :: (clearcolor: s32, clearstencil: s32, cleardepth: s32) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "clear");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushboolean(L, clearcolor);
	lua.pushboolean(L, clearstencil);
	lua.pushboolean(L, cleardepth);
	lua.call(L, 3, 0);
}
// Discards (trashes) the contents of the screen or active Canvas. This is a performance optimization function with niche use cases.
love_graphics_discard :: (discardcolor: s32, discardstencil: s32) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "discard");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushboolean(L, discardcolor);
	lua.pushboolean(L, discardstencil);
	lua.call(L, 2, 0);
}
// Discards (trashes) the contents of the screen or active Canvas. This is a performance optimization function with niche use cases.
love_graphics_discard :: (discardcolors: lua.Table, discardstencil: s32) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "discard");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.createtable(L, 0, 0);
	lua.pushboolean(L, discardstencil);
	lua.call(L, 2, 0);
}
// Draws a Drawable object (an Image, Canvas, SpriteBatch, ParticleSystem, Mesh, Text object, or Video) on the screen with optional rotation, scaling and shearing.
love_graphics_draw :: (drawable: Drawable, x: lua.Number, y: lua.Number, r: lua.Number, sx: lua.Number, sy: lua.Number, ox: lua.Number, oy: lua.Number, kx: lua.Number, ky: lua.Number) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "draw");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.rawgeti(L, lua.LUA_REGISTRYINDEX, xx drawable);
	lua.pushnumber(L, x);
	lua.pushnumber(L, y);
	lua.pushnumber(L, r);
	lua.pushnumber(L, sx);
	lua.pushnumber(L, sy);
	lua.pushnumber(L, ox);
	lua.pushnumber(L, oy);
	lua.pushnumber(L, kx);
	lua.pushnumber(L, ky);
	lua.call(L, 10, 0);
}
// Draws a Drawable object (an Image, Canvas, SpriteBatch, ParticleSystem, Mesh, Text object, or Video) on the screen with optional rotation, scaling and shearing.
love_graphics_draw :: (texture: Texture, quad: Quad, x: lua.Number, y: lua.Number, r: lua.Number, sx: lua.Number, sy: lua.Number, ox: lua.Number, oy: lua.Number, kx: lua.Number, ky: lua.Number) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "draw");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.rawgeti(L, lua.LUA_REGISTRYINDEX, xx texture);
	lua.rawgeti(L, lua.LUA_REGISTRYINDEX, xx quad);
	lua.pushnumber(L, x);
	lua.pushnumber(L, y);
	lua.pushnumber(L, r);
	lua.pushnumber(L, sx);
	lua.pushnumber(L, sy);
	lua.pushnumber(L, ox);
	lua.pushnumber(L, oy);
	lua.pushnumber(L, kx);
	lua.pushnumber(L, ky);
	lua.call(L, 11, 0);
}
// Draws a Drawable object (an Image, Canvas, SpriteBatch, ParticleSystem, Mesh, Text object, or Video) on the screen with optional rotation, scaling and shearing.
love_graphics_draw :: (drawable: Drawable, transform: Transform) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "draw");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.rawgeti(L, lua.LUA_REGISTRYINDEX, xx drawable);
	lua.rawgeti(L, lua.LUA_REGISTRYINDEX, xx transform);
	lua.call(L, 2, 0);
}
// Draws a Drawable object (an Image, Canvas, SpriteBatch, ParticleSystem, Mesh, Text object, or Video) on the screen with optional rotation, scaling and shearing.
love_graphics_draw :: (texture: Texture, quad: Quad, transform: Transform) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "draw");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.rawgeti(L, lua.LUA_REGISTRYINDEX, xx texture);
	lua.rawgeti(L, lua.LUA_REGISTRYINDEX, xx quad);
	lua.rawgeti(L, lua.LUA_REGISTRYINDEX, xx transform);
	lua.call(L, 3, 0);
}
// Draws many instances of a Mesh with a single draw call, using hardware geometry instancing.
love_graphics_drawInstanced :: (mesh: Mesh, instancecount: lua.Number, x: lua.Number, y: lua.Number, r: lua.Number, sx: lua.Number, sy: lua.Number, ox: lua.Number, oy: lua.Number, kx: lua.Number, ky: lua.Number) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "drawInstanced");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.rawgeti(L, lua.LUA_REGISTRYINDEX, xx mesh);
	lua.pushnumber(L, instancecount);
	lua.pushnumber(L, x);
	lua.pushnumber(L, y);
	lua.pushnumber(L, r);
	lua.pushnumber(L, sx);
	lua.pushnumber(L, sy);
	lua.pushnumber(L, ox);
	lua.pushnumber(L, oy);
	lua.pushnumber(L, kx);
	lua.pushnumber(L, ky);
	lua.call(L, 11, 0);
}
// Draws many instances of a Mesh with a single draw call, using hardware geometry instancing.
love_graphics_drawInstanced :: (mesh: Mesh, instancecount: lua.Number, transform: Transform) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "drawInstanced");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.rawgeti(L, lua.LUA_REGISTRYINDEX, xx mesh);
	lua.pushnumber(L, instancecount);
	lua.rawgeti(L, lua.LUA_REGISTRYINDEX, xx transform);
	lua.call(L, 3, 0);
}
// Draws a layer of an Array Texture.
love_graphics_drawLayer :: (texture: Texture, layerindex: lua.Number, x: lua.Number, y: lua.Number, r: lua.Number, sx: lua.Number, sy: lua.Number, ox: lua.Number, oy: lua.Number, kx: lua.Number, ky: lua.Number) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "drawLayer");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.rawgeti(L, lua.LUA_REGISTRYINDEX, xx texture);
	lua.pushnumber(L, layerindex);
	lua.pushnumber(L, x);
	lua.pushnumber(L, y);
	lua.pushnumber(L, r);
	lua.pushnumber(L, sx);
	lua.pushnumber(L, sy);
	lua.pushnumber(L, ox);
	lua.pushnumber(L, oy);
	lua.pushnumber(L, kx);
	lua.pushnumber(L, ky);
	lua.call(L, 11, 0);
}
// Draws a layer of an Array Texture.
love_graphics_drawLayer :: (texture: Texture, layerindex: lua.Number, quad: Quad, x: lua.Number, y: lua.Number, r: lua.Number, sx: lua.Number, sy: lua.Number, ox: lua.Number, oy: lua.Number, kx: lua.Number, ky: lua.Number) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "drawLayer");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.rawgeti(L, lua.LUA_REGISTRYINDEX, xx texture);
	lua.pushnumber(L, layerindex);
	lua.rawgeti(L, lua.LUA_REGISTRYINDEX, xx quad);
	lua.pushnumber(L, x);
	lua.pushnumber(L, y);
	lua.pushnumber(L, r);
	lua.pushnumber(L, sx);
	lua.pushnumber(L, sy);
	lua.pushnumber(L, ox);
	lua.pushnumber(L, oy);
	lua.pushnumber(L, kx);
	lua.pushnumber(L, ky);
	lua.call(L, 12, 0);
}
// Draws a layer of an Array Texture.
love_graphics_drawLayer :: (texture: Texture, layerindex: lua.Number, transform: Transform) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "drawLayer");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.rawgeti(L, lua.LUA_REGISTRYINDEX, xx texture);
	lua.pushnumber(L, layerindex);
	lua.rawgeti(L, lua.LUA_REGISTRYINDEX, xx transform);
	lua.call(L, 3, 0);
}
// Draws a layer of an Array Texture.
love_graphics_drawLayer :: (texture: Texture, layerindex: lua.Number, quad: Quad, transform: Transform) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "drawLayer");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.rawgeti(L, lua.LUA_REGISTRYINDEX, xx texture);
	lua.pushnumber(L, layerindex);
	lua.rawgeti(L, lua.LUA_REGISTRYINDEX, xx quad);
	lua.rawgeti(L, lua.LUA_REGISTRYINDEX, xx transform);
	lua.call(L, 4, 0);
}
// Draws an ellipse.
love_graphics_ellipse :: (mode: *u8, x: lua.Number, y: lua.Number, radiusx: lua.Number, radiusy: lua.Number) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "ellipse");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushstring(L, mode);
	lua.pushnumber(L, x);
	lua.pushnumber(L, y);
	lua.pushnumber(L, radiusx);
	lua.pushnumber(L, radiusy);
	lua.call(L, 5, 0);
}
// Draws an ellipse.
love_graphics_ellipse :: (mode: *u8, x: lua.Number, y: lua.Number, radiusx: lua.Number, radiusy: lua.Number, segments: lua.Number) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "ellipse");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushstring(L, mode);
	lua.pushnumber(L, x);
	lua.pushnumber(L, y);
	lua.pushnumber(L, radiusx);
	lua.pushnumber(L, radiusy);
	lua.pushnumber(L, segments);
	lua.call(L, 6, 0);
}
// Immediately renders any pending automatically batched draws.
love_graphics_flushBatch :: () #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "flushBatch");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.call(L, 0, 0);
}
// Gets the current background color.
love_graphics_getBackgroundColor :: () -> struct { _r: lua.Number; _g: lua.Number; _b: lua.Number; _a: lua.Number; } #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "getBackgroundColor");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.call(L, 0, 4);

	return .{ _r = lua.tonumber(L, -4), _g = lua.tonumber(L, -3), _b = lua.tonumber(L, -2), _a = lua.tonumber(L, -1) };
}
// Gets the blending mode.
love_graphics_getBlendMode :: () -> struct { _mode: *u8; _alphamode: *u8; } #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "getBlendMode");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.call(L, 0, 2);

	return .{ _mode = lua.tolstring(L, -2, null), _alphamode = lua.tolstring(L, -1, null) };
}
// Gets the current target Canvas.
love_graphics_getCanvas :: () -> (canvas: Canvas) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "getCanvas");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.call(L, 0, 1);

	return xx lua.luaL_ref(L, lua.LUA_REGISTRYINDEX);
}
// Gets the available Canvas formats, and whether each is supported.
love_graphics_getCanvasFormats :: () -> (formats: lua.Table) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "getCanvasFormats");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.call(L, 0, 1);

	return xx lua.luaL_ref(L, lua.LUA_REGISTRYINDEX);
}
// Gets the available Canvas formats, and whether each is supported.
love_graphics_getCanvasFormats :: (readable: s32) -> (formats: lua.Table) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "getCanvasFormats");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushboolean(L, readable);
	lua.call(L, 1, 1);

	return xx lua.luaL_ref(L, lua.LUA_REGISTRYINDEX);
}
// Gets the current color.
love_graphics_getColor :: () -> struct { _r: lua.Number; _g: lua.Number; _b: lua.Number; _a: lua.Number; } #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "getColor");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.call(L, 0, 4);

	return .{ _r = lua.tonumber(L, -4), _g = lua.tonumber(L, -3), _b = lua.tonumber(L, -2), _a = lua.tonumber(L, -1) };
}
// Gets the active color components used when drawing. Normally all 4 components are active unless love.graphics.setColorMask has been used.
love_graphics_getColorMask :: () -> struct { _r: s32; _g: s32; _b: s32; _a: s32; } #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "getColorMask");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.call(L, 0, 4);

	return .{ _r = lua.toboolean(L, -4), _g = lua.toboolean(L, -3), _b = lua.toboolean(L, -2), _a = lua.toboolean(L, -1) };
}
// Gets the DPI scale factor of the window.
love_graphics_getDPIScale :: () -> (scale: lua.Number) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "getDPIScale");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.call(L, 0, 1);

	return lua.tonumber(L, -1);
}
// Returns the default scaling filters used with Images, Canvases, and Fonts.
love_graphics_getDefaultFilter :: () -> struct { _min: *u8; _mag: *u8; _anisotropy: lua.Number; } #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "getDefaultFilter");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.call(L, 0, 3);

	return .{ _min = lua.tolstring(L, -3, null), _mag = lua.tolstring(L, -2, null), _anisotropy = lua.tonumber(L, -1) };
}
// Gets the current depth test mode and whether writing to the depth buffer is enabled.
love_graphics_getDepthMode :: () -> struct { _comparemode: *u8; _write: s32; } #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "getDepthMode");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.call(L, 0, 2);

	return .{ _comparemode = lua.tolstring(L, -2, null), _write = lua.toboolean(L, -1) };
}
// Gets the width and height in pixels of the window.
love_graphics_getDimensions :: () -> struct { _width: lua.Number; _height: lua.Number; } #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "getDimensions");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.call(L, 0, 2);

	return .{ _width = lua.tonumber(L, -2), _height = lua.tonumber(L, -1) };
}
// Gets the current Font object.
love_graphics_getFont :: () -> (font: Font) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "getFont");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.call(L, 0, 1);

	return xx lua.luaL_ref(L, lua.LUA_REGISTRYINDEX);
}
// Gets whether triangles with clockwise- or counterclockwise-ordered vertices are considered front-facing.
love_graphics_getFrontFaceWinding :: () -> (winding: *u8) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "getFrontFaceWinding");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.call(L, 0, 1);

	return lua.tolstring(L, -1, null);
}
// Gets the height in pixels of the window.
love_graphics_getHeight :: () -> (height: lua.Number) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "getHeight");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.call(L, 0, 1);

	return lua.tonumber(L, -1);
}
// Gets the raw and compressed pixel formats usable for Images, and whether each is supported.
love_graphics_getImageFormats :: () -> (formats: lua.Table) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "getImageFormats");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.call(L, 0, 1);

	return xx lua.luaL_ref(L, lua.LUA_REGISTRYINDEX);
}
// Gets the line join style.
love_graphics_getLineJoin :: () -> (join: *u8) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "getLineJoin");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.call(L, 0, 1);

	return lua.tolstring(L, -1, null);
}
// Gets the line style.
love_graphics_getLineStyle :: () -> (style: *u8) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "getLineStyle");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.call(L, 0, 1);

	return lua.tolstring(L, -1, null);
}
// Gets the current line width.
love_graphics_getLineWidth :: () -> (width: lua.Number) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "getLineWidth");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.call(L, 0, 1);

	return lua.tonumber(L, -1);
}
// Gets whether back-facing triangles in a Mesh are culled.
love_graphics_getMeshCullMode :: () -> (mode: *u8) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "getMeshCullMode");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.call(L, 0, 1);

	return lua.tolstring(L, -1, null);
}
// Gets the width and height in pixels of the window.
love_graphics_getPixelDimensions :: () -> struct { _pixelwidth: lua.Number; _pixelheight: lua.Number; } #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "getPixelDimensions");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.call(L, 0, 2);

	return .{ _pixelwidth = lua.tonumber(L, -2), _pixelheight = lua.tonumber(L, -1) };
}
// Gets the height in pixels of the window.
love_graphics_getPixelHeight :: () -> (pixelheight: lua.Number) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "getPixelHeight");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.call(L, 0, 1);

	return lua.tonumber(L, -1);
}
// Gets the width in pixels of the window.
love_graphics_getPixelWidth :: () -> (pixelwidth: lua.Number) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "getPixelWidth");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.call(L, 0, 1);

	return lua.tonumber(L, -1);
}
// Gets the point size.
love_graphics_getPointSize :: () -> (size: lua.Number) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "getPointSize");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.call(L, 0, 1);

	return lua.tonumber(L, -1);
}
// Gets information about the system's video card and drivers.
love_graphics_getRendererInfo :: () -> struct { _name: *u8; _version: *u8; _vendor: *u8; _device: *u8; } #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "getRendererInfo");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.call(L, 0, 4);

	return .{ _name = lua.tolstring(L, -4, null), _version = lua.tolstring(L, -3, null), _vendor = lua.tolstring(L, -2, null), _device = lua.tolstring(L, -1, null) };
}
// Gets the current scissor box.
love_graphics_getScissor :: () -> struct { _x: lua.Number; _y: lua.Number; _width: lua.Number; _height: lua.Number; } #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "getScissor");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.call(L, 0, 4);

	return .{ _x = lua.tonumber(L, -4), _y = lua.tonumber(L, -3), _width = lua.tonumber(L, -2), _height = lua.tonumber(L, -1) };
}
// Gets the current Shader. Returns nil if none is set.
love_graphics_getShader :: () -> (shader: Shader) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "getShader");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.call(L, 0, 1);

	return xx lua.luaL_ref(L, lua.LUA_REGISTRYINDEX);
}
// Gets the current depth of the transform / state stack (the number of pushes without corresponding pops).
love_graphics_getStackDepth :: () -> (depth: lua.Number) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "getStackDepth");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.call(L, 0, 1);

	return lua.tonumber(L, -1);
}
// Gets performance-related rendering statistics. 
love_graphics_getStats :: () -> (stats: lua.Table) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "getStats");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.call(L, 0, 1);

	return xx lua.luaL_ref(L, lua.LUA_REGISTRYINDEX);
}
// Gets performance-related rendering statistics. 
love_graphics_getStats :: (stats: lua.Table) -> (stats: lua.Table) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "getStats");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.createtable(L, 0, 0);
	lua.call(L, 1, 1);

	return xx lua.luaL_ref(L, lua.LUA_REGISTRYINDEX);
}
// Gets the current stencil test configuration.
love_graphics_getStencilTest :: () -> struct { _comparemode: *u8; _comparevalue: lua.Number; } #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "getStencilTest");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.call(L, 0, 2);

	return .{ _comparemode = lua.tolstring(L, -2, null), _comparevalue = lua.tonumber(L, -1) };
}
// Gets the optional graphics features and whether they're supported on the system.
love_graphics_getSupported :: () -> (features: lua.Table) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "getSupported");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.call(L, 0, 1);

	return xx lua.luaL_ref(L, lua.LUA_REGISTRYINDEX);
}
// Gets the system-dependent maximum values for love.graphics features.
love_graphics_getSystemLimits :: () -> (limits: lua.Table) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "getSystemLimits");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.call(L, 0, 1);

	return xx lua.luaL_ref(L, lua.LUA_REGISTRYINDEX);
}
// Gets the available texture types, and whether each is supported.
love_graphics_getTextureTypes :: () -> (texturetypes: lua.Table) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "getTextureTypes");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.call(L, 0, 1);

	return xx lua.luaL_ref(L, lua.LUA_REGISTRYINDEX);
}
// Gets the width in pixels of the window.
love_graphics_getWidth :: () -> (width: lua.Number) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "getWidth");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.call(L, 0, 1);

	return lua.tonumber(L, -1);
}
// Sets the scissor to the rectangle created by the intersection of the specified rectangle with the existing scissor.  If no scissor is active yet, it behaves like love.graphics.setScissor.
love_graphics_intersectScissor :: (x: lua.Number, y: lua.Number, width: lua.Number, height: lua.Number) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "intersectScissor");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushnumber(L, x);
	lua.pushnumber(L, y);
	lua.pushnumber(L, width);
	lua.pushnumber(L, height);
	lua.call(L, 4, 0);
}
// Converts the given 2D position from screen-space into global coordinates.
love_graphics_inverseTransformPoint :: (screenx: lua.Number, screeny: lua.Number) -> struct { _globalx: lua.Number; _globaly: lua.Number; } #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "inverseTransformPoint");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushnumber(L, screenx);
	lua.pushnumber(L, screeny);
	lua.call(L, 2, 2);

	return .{ _globalx = lua.tonumber(L, -2), _globaly = lua.tonumber(L, -1) };
}
// Gets whether the graphics module is able to be used. If it is not active, love.graphics function and method calls will not work correctly and may cause the program to crash.
love_graphics_isActive :: () -> (active: s32) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "isActive");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.call(L, 0, 1);

	return lua.toboolean(L, -1);
}
// Gets whether gamma-correct rendering is supported and enabled. It can be enabled by setting t.gammacorrect = true in love.conf.
love_graphics_isGammaCorrect :: () -> (gammacorrect: s32) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "isGammaCorrect");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.call(L, 0, 1);

	return lua.toboolean(L, -1);
}
// Gets whether wireframe mode is used when drawing.
love_graphics_isWireframe :: () -> (wireframe: s32) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "isWireframe");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.call(L, 0, 1);

	return lua.toboolean(L, -1);
}
// Draws lines between points.
love_graphics_line :: (x1: lua.Number, y1: lua.Number, x2: lua.Number, y2: lua.Number) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "line");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushnumber(L, x1);
	lua.pushnumber(L, y1);
	lua.pushnumber(L, x2);
	lua.pushnumber(L, y2);
	lua.call(L, 4, 0);
}
// Draws lines between points.
love_graphics_line :: (points: lua.Table) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "line");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.createtable(L, 0, 0);
	lua.call(L, 1, 0);
}
// Creates a new array Image.
love_graphics_newArrayImage :: (slices: lua.Table, settings: lua.Table) -> (image: Image) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "newArrayImage");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.createtable(L, 0, 0);
	lua.createtable(L, 0, 0);
	lua.call(L, 2, 1);

	return xx lua.luaL_ref(L, lua.LUA_REGISTRYINDEX);
}
// Creates a new Canvas object for offscreen rendering.
love_graphics_newCanvas :: () -> (canvas: Canvas) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "newCanvas");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.call(L, 0, 1);

	return xx lua.luaL_ref(L, lua.LUA_REGISTRYINDEX);
}
// Creates a new Canvas object for offscreen rendering.
love_graphics_newCanvas :: (width: lua.Number, height: lua.Number) -> (canvas: Canvas) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "newCanvas");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushnumber(L, width);
	lua.pushnumber(L, height);
	lua.call(L, 2, 1);

	return xx lua.luaL_ref(L, lua.LUA_REGISTRYINDEX);
}
// Creates a new Canvas object for offscreen rendering.
love_graphics_newCanvas :: (width: lua.Number, height: lua.Number, settings: lua.Table) -> (canvas: Canvas) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "newCanvas");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushnumber(L, width);
	lua.pushnumber(L, height);
	lua.createtable(L, 0, 0);
	lua.call(L, 3, 1);

	return xx lua.luaL_ref(L, lua.LUA_REGISTRYINDEX);
}
// Creates a new Canvas object for offscreen rendering.
love_graphics_newCanvas :: (width: lua.Number, height: lua.Number, layers: lua.Number, settings: lua.Table) -> (canvas: Canvas) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "newCanvas");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushnumber(L, width);
	lua.pushnumber(L, height);
	lua.pushnumber(L, layers);
	lua.createtable(L, 0, 0);
	lua.call(L, 4, 1);

	return xx lua.luaL_ref(L, lua.LUA_REGISTRYINDEX);
}
// Creates a new cubemap Image.
love_graphics_newCubeImage :: (filename: *u8, settings: lua.Table) -> (image: Image) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "newCubeImage");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushstring(L, filename);
	lua.createtable(L, 0, 0);
	lua.call(L, 2, 1);

	return xx lua.luaL_ref(L, lua.LUA_REGISTRYINDEX);
}
// Creates a new cubemap Image.
love_graphics_newCubeImage :: (faces: lua.Table, settings: lua.Table) -> (image: Image) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "newCubeImage");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.createtable(L, 0, 0);
	lua.createtable(L, 0, 0);
	lua.call(L, 2, 1);

	return xx lua.luaL_ref(L, lua.LUA_REGISTRYINDEX);
}
// Creates a new Font from a TrueType Font or BMFont file. Created fonts are not cached, in that calling this function with the same arguments will always create a new Font object.
love_graphics_newFont :: (filename: *u8) -> (font: Font) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "newFont");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushstring(L, filename);
	lua.call(L, 1, 1);

	return xx lua.luaL_ref(L, lua.LUA_REGISTRYINDEX);
}
// Creates a new Font from a TrueType Font or BMFont file. Created fonts are not cached, in that calling this function with the same arguments will always create a new Font object.
love_graphics_newFont :: (filename: *u8, size: lua.Number, hinting: *u8, dpiscale: lua.Number) -> (font: Font) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "newFont");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushstring(L, filename);
	lua.pushnumber(L, size);
	lua.pushstring(L, hinting);
	lua.pushnumber(L, dpiscale);
	lua.call(L, 4, 1);

	return xx lua.luaL_ref(L, lua.LUA_REGISTRYINDEX);
}
// Creates a new Font from a TrueType Font or BMFont file. Created fonts are not cached, in that calling this function with the same arguments will always create a new Font object.
love_graphics_newFont :: (filename: *u8, imagefilename: *u8) -> (font: Font) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "newFont");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushstring(L, filename);
	lua.pushstring(L, imagefilename);
	lua.call(L, 2, 1);

	return xx lua.luaL_ref(L, lua.LUA_REGISTRYINDEX);
}
// Creates a new Font from a TrueType Font or BMFont file. Created fonts are not cached, in that calling this function with the same arguments will always create a new Font object.
love_graphics_newFont :: (size: lua.Number, hinting: *u8, dpiscale: lua.Number) -> (font: Font) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "newFont");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushnumber(L, size);
	lua.pushstring(L, hinting);
	lua.pushnumber(L, dpiscale);
	lua.call(L, 3, 1);

	return xx lua.luaL_ref(L, lua.LUA_REGISTRYINDEX);
}
// Creates a new Image from a filepath, FileData, an ImageData, or a CompressedImageData, and optionally generates or specifies mipmaps for the image.
love_graphics_newImage :: (filename: *u8, settings: lua.Table) -> (image: Image) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "newImage");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushstring(L, filename);
	lua.createtable(L, 0, 0);
	lua.call(L, 2, 1);

	return xx lua.luaL_ref(L, lua.LUA_REGISTRYINDEX);
}
// Creates a new Image from a filepath, FileData, an ImageData, or a CompressedImageData, and optionally generates or specifies mipmaps for the image.
love_graphics_newImage :: (filedata: FileData, settings: lua.Table) -> (image: Image) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "newImage");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.rawgeti(L, lua.LUA_REGISTRYINDEX, xx filedata);
	lua.createtable(L, 0, 0);
	lua.call(L, 2, 1);

	return xx lua.luaL_ref(L, lua.LUA_REGISTRYINDEX);
}
// Creates a new Image from a filepath, FileData, an ImageData, or a CompressedImageData, and optionally generates or specifies mipmaps for the image.
love_graphics_newImage :: (imagedata: ImageData, settings: lua.Table) -> (image: Image) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "newImage");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.rawgeti(L, lua.LUA_REGISTRYINDEX, xx imagedata);
	lua.createtable(L, 0, 0);
	lua.call(L, 2, 1);

	return xx lua.luaL_ref(L, lua.LUA_REGISTRYINDEX);
}
// Creates a new Image from a filepath, FileData, an ImageData, or a CompressedImageData, and optionally generates or specifies mipmaps for the image.
love_graphics_newImage :: (compressedimagedata: CompressedImageData, settings: lua.Table) -> (image: Image) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "newImage");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.rawgeti(L, lua.LUA_REGISTRYINDEX, xx compressedimagedata);
	lua.createtable(L, 0, 0);
	lua.call(L, 2, 1);

	return xx lua.luaL_ref(L, lua.LUA_REGISTRYINDEX);
}
// Creates a new specifically formatted image.
love_graphics_newImageFont :: (filename: *u8, glyphs: *u8) -> (font: Font) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "newImageFont");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushstring(L, filename);
	lua.pushstring(L, glyphs);
	lua.call(L, 2, 1);

	return xx lua.luaL_ref(L, lua.LUA_REGISTRYINDEX);
}
// Creates a new specifically formatted image.
love_graphics_newImageFont :: (imagedata: ImageData, glyphs: *u8) -> (font: Font) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "newImageFont");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.rawgeti(L, lua.LUA_REGISTRYINDEX, xx imagedata);
	lua.pushstring(L, glyphs);
	lua.call(L, 2, 1);

	return xx lua.luaL_ref(L, lua.LUA_REGISTRYINDEX);
}
// Creates a new specifically formatted image.
love_graphics_newImageFont :: (filename: *u8, glyphs: *u8, extraspacing: lua.Number) -> (font: Font) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "newImageFont");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushstring(L, filename);
	lua.pushstring(L, glyphs);
	lua.pushnumber(L, extraspacing);
	lua.call(L, 3, 1);

	return xx lua.luaL_ref(L, lua.LUA_REGISTRYINDEX);
}
// Creates a new Mesh.
love_graphics_newMesh :: (vertices: lua.Table, mode: *u8, usage: *u8) -> (mesh: Mesh) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "newMesh");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.createtable(L, 0, 0);
	lua.pushstring(L, mode);
	lua.pushstring(L, usage);
	lua.call(L, 3, 1);

	return xx lua.luaL_ref(L, lua.LUA_REGISTRYINDEX);
}
// Creates a new Mesh.
love_graphics_newMesh :: (vertexcount: lua.Number, mode: *u8, usage: *u8) -> (mesh: Mesh) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "newMesh");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushnumber(L, vertexcount);
	lua.pushstring(L, mode);
	lua.pushstring(L, usage);
	lua.call(L, 3, 1);

	return xx lua.luaL_ref(L, lua.LUA_REGISTRYINDEX);
}
// Creates a new Mesh.
love_graphics_newMesh :: (vertexformat: lua.Table, vertices: lua.Table, mode: *u8, usage: *u8) -> (mesh: Mesh) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "newMesh");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.createtable(L, 0, 0);
	lua.createtable(L, 0, 0);
	lua.pushstring(L, mode);
	lua.pushstring(L, usage);
	lua.call(L, 4, 1);

	return xx lua.luaL_ref(L, lua.LUA_REGISTRYINDEX);
}
// Creates a new Mesh.
love_graphics_newMesh :: (vertexformat: lua.Table, vertexcount: lua.Number, mode: *u8, usage: *u8) -> (mesh: Mesh) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "newMesh");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.createtable(L, 0, 0);
	lua.pushnumber(L, vertexcount);
	lua.pushstring(L, mode);
	lua.pushstring(L, usage);
	lua.call(L, 4, 1);

	return xx lua.luaL_ref(L, lua.LUA_REGISTRYINDEX);
}
// Creates a new Mesh.
love_graphics_newMesh :: (vertexcount: lua.Number, texture: Texture, mode: *u8) -> (mesh: Mesh) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "newMesh");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushnumber(L, vertexcount);
	lua.rawgeti(L, lua.LUA_REGISTRYINDEX, xx texture);
	lua.pushstring(L, mode);
	lua.call(L, 3, 1);

	return xx lua.luaL_ref(L, lua.LUA_REGISTRYINDEX);
}
// Creates a new ParticleSystem.
love_graphics_newParticleSystem :: (image: Image, buffer: lua.Number) -> (system: ParticleSystem) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "newParticleSystem");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.rawgeti(L, lua.LUA_REGISTRYINDEX, xx image);
	lua.pushnumber(L, buffer);
	lua.call(L, 2, 1);

	return xx lua.luaL_ref(L, lua.LUA_REGISTRYINDEX);
}
// Creates a new ParticleSystem.
love_graphics_newParticleSystem :: (texture: Texture, buffer: lua.Number) -> (system: ParticleSystem) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "newParticleSystem");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.rawgeti(L, lua.LUA_REGISTRYINDEX, xx texture);
	lua.pushnumber(L, buffer);
	lua.call(L, 2, 1);

	return xx lua.luaL_ref(L, lua.LUA_REGISTRYINDEX);
}
// Creates a new Quad.
love_graphics_newQuad :: (x: lua.Number, y: lua.Number, width: lua.Number, height: lua.Number, sw: lua.Number, sh: lua.Number) -> (quad: Quad) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "newQuad");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushnumber(L, x);
	lua.pushnumber(L, y);
	lua.pushnumber(L, width);
	lua.pushnumber(L, height);
	lua.pushnumber(L, sw);
	lua.pushnumber(L, sh);
	lua.call(L, 6, 1);

	return xx lua.luaL_ref(L, lua.LUA_REGISTRYINDEX);
}
// Creates a new Shader object for hardware-accelerated vertex and pixel effects. A Shader contains either vertex shader code, pixel shader code, or both.
love_graphics_newShader :: (code: *u8) -> (shader: Shader) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "newShader");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushstring(L, code);
	lua.call(L, 1, 1);

	return xx lua.luaL_ref(L, lua.LUA_REGISTRYINDEX);
}
// Creates a new Shader object for hardware-accelerated vertex and pixel effects. A Shader contains either vertex shader code, pixel shader code, or both.
love_graphics_newShader :: (pixelcode: *u8, vertexcode: *u8) -> (shader: Shader) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "newShader");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushstring(L, pixelcode);
	lua.pushstring(L, vertexcode);
	lua.call(L, 2, 1);

	return xx lua.luaL_ref(L, lua.LUA_REGISTRYINDEX);
}
// Creates a new SpriteBatch object.
love_graphics_newSpriteBatch :: (image: Image, maxsprites: lua.Number) -> (spritebatch: SpriteBatch) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "newSpriteBatch");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.rawgeti(L, lua.LUA_REGISTRYINDEX, xx image);
	lua.pushnumber(L, maxsprites);
	lua.call(L, 2, 1);

	return xx lua.luaL_ref(L, lua.LUA_REGISTRYINDEX);
}
// Creates a new SpriteBatch object.
love_graphics_newSpriteBatch :: (image: Image, maxsprites: lua.Number, usage: *u8) -> (spritebatch: SpriteBatch) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "newSpriteBatch");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.rawgeti(L, lua.LUA_REGISTRYINDEX, xx image);
	lua.pushnumber(L, maxsprites);
	lua.pushstring(L, usage);
	lua.call(L, 3, 1);

	return xx lua.luaL_ref(L, lua.LUA_REGISTRYINDEX);
}
// Creates a new SpriteBatch object.
love_graphics_newSpriteBatch :: (texture: Texture, maxsprites: lua.Number, usage: *u8) -> (spritebatch: SpriteBatch) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "newSpriteBatch");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.rawgeti(L, lua.LUA_REGISTRYINDEX, xx texture);
	lua.pushnumber(L, maxsprites);
	lua.pushstring(L, usage);
	lua.call(L, 3, 1);

	return xx lua.luaL_ref(L, lua.LUA_REGISTRYINDEX);
}
// Creates a new drawable Text object.
love_graphics_newText :: (font: Font, textstring: *u8) -> (text: Text) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "newText");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.rawgeti(L, lua.LUA_REGISTRYINDEX, xx font);
	lua.pushstring(L, textstring);
	lua.call(L, 2, 1);

	return xx lua.luaL_ref(L, lua.LUA_REGISTRYINDEX);
}
// Creates a new drawable Video. Currently only Ogg Theora video files are supported.
love_graphics_newVideo :: (filename: *u8) -> (video: Video) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "newVideo");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushstring(L, filename);
	lua.call(L, 1, 1);

	return xx lua.luaL_ref(L, lua.LUA_REGISTRYINDEX);
}
// Creates a new drawable Video. Currently only Ogg Theora video files are supported.
love_graphics_newVideo :: (videostream: VideoStream) -> (video: Video) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "newVideo");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.rawgeti(L, lua.LUA_REGISTRYINDEX, xx videostream);
	lua.call(L, 1, 1);

	return xx lua.luaL_ref(L, lua.LUA_REGISTRYINDEX);
}
// Creates a new drawable Video. Currently only Ogg Theora video files are supported.
love_graphics_newVideo :: (filename: *u8, settings: lua.Table) -> (video: Video) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "newVideo");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushstring(L, filename);
	lua.createtable(L, 0, 0);
	lua.call(L, 2, 1);

	return xx lua.luaL_ref(L, lua.LUA_REGISTRYINDEX);
}
// Creates a new drawable Video. Currently only Ogg Theora video files are supported.
love_graphics_newVideo :: (filename: *u8, loadaudio: s32) -> (video: Video) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "newVideo");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushstring(L, filename);
	lua.pushboolean(L, loadaudio);
	lua.call(L, 2, 1);

	return xx lua.luaL_ref(L, lua.LUA_REGISTRYINDEX);
}
// Creates a new drawable Video. Currently only Ogg Theora video files are supported.
love_graphics_newVideo :: (videostream: VideoStream, loadaudio: s32) -> (video: Video) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "newVideo");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.rawgeti(L, lua.LUA_REGISTRYINDEX, xx videostream);
	lua.pushboolean(L, loadaudio);
	lua.call(L, 2, 1);

	return xx lua.luaL_ref(L, lua.LUA_REGISTRYINDEX);
}
// Creates a new volume (3D) Image.
love_graphics_newVolumeImage :: (layers: lua.Table, settings: lua.Table) -> (image: Image) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "newVolumeImage");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.createtable(L, 0, 0);
	lua.createtable(L, 0, 0);
	lua.call(L, 2, 1);

	return xx lua.luaL_ref(L, lua.LUA_REGISTRYINDEX);
}
// Resets the current coordinate transformation.
love_graphics_origin :: () #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "origin");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.call(L, 0, 0);
}
// Draws one or more points.
love_graphics_points :: (x: lua.Number, y: lua.Number) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "points");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushnumber(L, x);
	lua.pushnumber(L, y);
	lua.call(L, 2, 0);
}
// Draws one or more points.
love_graphics_points :: (points: lua.Table) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "points");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.createtable(L, 0, 0);
	lua.call(L, 1, 0);
}
// Draws one or more points.
// Draw a polygon.
love_graphics_polygon :: (mode: *u8) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "polygon");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushstring(L, mode);
	lua.call(L, 1, 0);
}
// Draw a polygon.
love_graphics_polygon :: (mode: *u8, vertices: lua.Table) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "polygon");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushstring(L, mode);
	lua.createtable(L, 0, 0);
	lua.call(L, 2, 0);
}
// Pops the current coordinate transformation from the transformation stack.
love_graphics_pop :: () #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "pop");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.call(L, 0, 0);
}
// Displays the results of drawing operations on the screen.
love_graphics_present :: () #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "present");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.call(L, 0, 0);
}
// Draws text on screen. If no Font is set, one will be created and set (once) if needed.
love_graphics_print :: (text: *u8, x: lua.Number, y: lua.Number, r: lua.Number, sx: lua.Number, sy: lua.Number, ox: lua.Number, oy: lua.Number, kx: lua.Number, ky: lua.Number) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "print");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushstring(L, text);
	lua.pushnumber(L, x);
	lua.pushnumber(L, y);
	lua.pushnumber(L, r);
	lua.pushnumber(L, sx);
	lua.pushnumber(L, sy);
	lua.pushnumber(L, ox);
	lua.pushnumber(L, oy);
	lua.pushnumber(L, kx);
	lua.pushnumber(L, ky);
	lua.call(L, 10, 0);
}
// Draws text on screen. If no Font is set, one will be created and set (once) if needed.
love_graphics_print :: (coloredtext: lua.Table, x: lua.Number, y: lua.Number, angle: lua.Number, sx: lua.Number, sy: lua.Number, ox: lua.Number, oy: lua.Number, kx: lua.Number, ky: lua.Number) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "print");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.createtable(L, 0, 0);
	lua.pushnumber(L, x);
	lua.pushnumber(L, y);
	lua.pushnumber(L, angle);
	lua.pushnumber(L, sx);
	lua.pushnumber(L, sy);
	lua.pushnumber(L, ox);
	lua.pushnumber(L, oy);
	lua.pushnumber(L, kx);
	lua.pushnumber(L, ky);
	lua.call(L, 10, 0);
}
// Draws text on screen. If no Font is set, one will be created and set (once) if needed.
love_graphics_print :: (text: *u8, transform: Transform) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "print");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushstring(L, text);
	lua.rawgeti(L, lua.LUA_REGISTRYINDEX, xx transform);
	lua.call(L, 2, 0);
}
// Draws text on screen. If no Font is set, one will be created and set (once) if needed.
love_graphics_print :: (coloredtext: lua.Table, transform: Transform) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "print");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.createtable(L, 0, 0);
	lua.rawgeti(L, lua.LUA_REGISTRYINDEX, xx transform);
	lua.call(L, 2, 0);
}
// Draws text on screen. If no Font is set, one will be created and set (once) if needed.
love_graphics_print :: (text: *u8, font: Font, transform: Transform) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "print");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushstring(L, text);
	lua.rawgeti(L, lua.LUA_REGISTRYINDEX, xx font);
	lua.rawgeti(L, lua.LUA_REGISTRYINDEX, xx transform);
	lua.call(L, 3, 0);
}
// Draws text on screen. If no Font is set, one will be created and set (once) if needed.
love_graphics_print :: (coloredtext: lua.Table, font: Font, transform: Transform) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "print");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.createtable(L, 0, 0);
	lua.rawgeti(L, lua.LUA_REGISTRYINDEX, xx font);
	lua.rawgeti(L, lua.LUA_REGISTRYINDEX, xx transform);
	lua.call(L, 3, 0);
}
// Draws formatted text, with word wrap and alignment.
love_graphics_printf :: (text: *u8, x: lua.Number, y: lua.Number, limit: lua.Number, align: *u8, r: lua.Number, sx: lua.Number, sy: lua.Number, ox: lua.Number, oy: lua.Number, kx: lua.Number, ky: lua.Number) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "printf");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushstring(L, text);
	lua.pushnumber(L, x);
	lua.pushnumber(L, y);
	lua.pushnumber(L, limit);
	lua.pushstring(L, align);
	lua.pushnumber(L, r);
	lua.pushnumber(L, sx);
	lua.pushnumber(L, sy);
	lua.pushnumber(L, ox);
	lua.pushnumber(L, oy);
	lua.pushnumber(L, kx);
	lua.pushnumber(L, ky);
	lua.call(L, 12, 0);
}
// Draws formatted text, with word wrap and alignment.
love_graphics_printf :: (text: *u8, font: Font, x: lua.Number, y: lua.Number, limit: lua.Number, align: *u8, r: lua.Number, sx: lua.Number, sy: lua.Number, ox: lua.Number, oy: lua.Number, kx: lua.Number, ky: lua.Number) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "printf");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushstring(L, text);
	lua.rawgeti(L, lua.LUA_REGISTRYINDEX, xx font);
	lua.pushnumber(L, x);
	lua.pushnumber(L, y);
	lua.pushnumber(L, limit);
	lua.pushstring(L, align);
	lua.pushnumber(L, r);
	lua.pushnumber(L, sx);
	lua.pushnumber(L, sy);
	lua.pushnumber(L, ox);
	lua.pushnumber(L, oy);
	lua.pushnumber(L, kx);
	lua.pushnumber(L, ky);
	lua.call(L, 13, 0);
}
// Draws formatted text, with word wrap and alignment.
love_graphics_printf :: (text: *u8, transform: Transform, limit: lua.Number, align: *u8) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "printf");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushstring(L, text);
	lua.rawgeti(L, lua.LUA_REGISTRYINDEX, xx transform);
	lua.pushnumber(L, limit);
	lua.pushstring(L, align);
	lua.call(L, 4, 0);
}
// Draws formatted text, with word wrap and alignment.
love_graphics_printf :: (text: *u8, font: Font, transform: Transform, limit: lua.Number, align: *u8) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "printf");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushstring(L, text);
	lua.rawgeti(L, lua.LUA_REGISTRYINDEX, xx font);
	lua.rawgeti(L, lua.LUA_REGISTRYINDEX, xx transform);
	lua.pushnumber(L, limit);
	lua.pushstring(L, align);
	lua.call(L, 5, 0);
}
// Draws formatted text, with word wrap and alignment.
love_graphics_printf :: (coloredtext: lua.Table, x: lua.Number, y: lua.Number, limit: lua.Number, align: *u8, angle: lua.Number, sx: lua.Number, sy: lua.Number, ox: lua.Number, oy: lua.Number, kx: lua.Number, ky: lua.Number) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "printf");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.createtable(L, 0, 0);
	lua.pushnumber(L, x);
	lua.pushnumber(L, y);
	lua.pushnumber(L, limit);
	lua.pushstring(L, align);
	lua.pushnumber(L, angle);
	lua.pushnumber(L, sx);
	lua.pushnumber(L, sy);
	lua.pushnumber(L, ox);
	lua.pushnumber(L, oy);
	lua.pushnumber(L, kx);
	lua.pushnumber(L, ky);
	lua.call(L, 12, 0);
}
// Draws formatted text, with word wrap and alignment.
love_graphics_printf :: (coloredtext: lua.Table, font: Font, x: lua.Number, y: lua.Number, limit: lua.Number, align: *u8, angle: lua.Number, sx: lua.Number, sy: lua.Number, ox: lua.Number, oy: lua.Number, kx: lua.Number, ky: lua.Number) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "printf");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.createtable(L, 0, 0);
	lua.rawgeti(L, lua.LUA_REGISTRYINDEX, xx font);
	lua.pushnumber(L, x);
	lua.pushnumber(L, y);
	lua.pushnumber(L, limit);
	lua.pushstring(L, align);
	lua.pushnumber(L, angle);
	lua.pushnumber(L, sx);
	lua.pushnumber(L, sy);
	lua.pushnumber(L, ox);
	lua.pushnumber(L, oy);
	lua.pushnumber(L, kx);
	lua.pushnumber(L, ky);
	lua.call(L, 13, 0);
}
// Draws formatted text, with word wrap and alignment.
love_graphics_printf :: (coloredtext: lua.Table, transform: Transform, limit: lua.Number, align: *u8) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "printf");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.createtable(L, 0, 0);
	lua.rawgeti(L, lua.LUA_REGISTRYINDEX, xx transform);
	lua.pushnumber(L, limit);
	lua.pushstring(L, align);
	lua.call(L, 4, 0);
}
// Draws formatted text, with word wrap and alignment.
love_graphics_printf :: (coloredtext: lua.Table, font: Font, transform: Transform, limit: lua.Number, align: *u8) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "printf");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.createtable(L, 0, 0);
	lua.rawgeti(L, lua.LUA_REGISTRYINDEX, xx font);
	lua.rawgeti(L, lua.LUA_REGISTRYINDEX, xx transform);
	lua.pushnumber(L, limit);
	lua.pushstring(L, align);
	lua.call(L, 5, 0);
}
// Copies and pushes the current coordinate transformation to the transformation stack.
love_graphics_push :: () #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "push");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.call(L, 0, 0);
}
// Copies and pushes the current coordinate transformation to the transformation stack.
love_graphics_push :: (stack: *u8) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "push");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushstring(L, stack);
	lua.call(L, 1, 0);
}
// Draws a rectangle.
love_graphics_rectangle :: (mode: *u8, x: lua.Number, y: lua.Number, width: lua.Number, height: lua.Number) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "rectangle");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushstring(L, mode);
	lua.pushnumber(L, x);
	lua.pushnumber(L, y);
	lua.pushnumber(L, width);
	lua.pushnumber(L, height);
	lua.call(L, 5, 0);
}
// Draws a rectangle.
love_graphics_rectangle :: (mode: *u8, x: lua.Number, y: lua.Number, width: lua.Number, height: lua.Number, rx: lua.Number, ry: lua.Number, segments: lua.Number) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "rectangle");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushstring(L, mode);
	lua.pushnumber(L, x);
	lua.pushnumber(L, y);
	lua.pushnumber(L, width);
	lua.pushnumber(L, height);
	lua.pushnumber(L, rx);
	lua.pushnumber(L, ry);
	lua.pushnumber(L, segments);
	lua.call(L, 8, 0);
}
// Replaces the current coordinate transformation with the given Transform object.
love_graphics_replaceTransform :: (transform: Transform) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "replaceTransform");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.rawgeti(L, lua.LUA_REGISTRYINDEX, xx transform);
	lua.call(L, 1, 0);
}
// Resets the current graphics settings.
love_graphics_reset :: () #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "reset");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.call(L, 0, 0);
}
// Rotates the coordinate system in two dimensions.
love_graphics_rotate :: (angle: lua.Number) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "rotate");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushnumber(L, angle);
	lua.call(L, 1, 0);
}
// Scales the coordinate system in two dimensions.
love_graphics_scale :: (sx: lua.Number, sy: lua.Number) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "scale");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushnumber(L, sx);
	lua.pushnumber(L, sy);
	lua.call(L, 2, 0);
}
// Sets the background color.
love_graphics_setBackgroundColor :: (red: lua.Number, green: lua.Number, blue: lua.Number, alpha: lua.Number) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "setBackgroundColor");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushnumber(L, red);
	lua.pushnumber(L, green);
	lua.pushnumber(L, blue);
	lua.pushnumber(L, alpha);
	lua.call(L, 4, 0);
}
// Sets the background color.
love_graphics_setBackgroundColor :: (rgba: lua.Table) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "setBackgroundColor");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.createtable(L, 0, 0);
	lua.call(L, 1, 0);
}
// Sets the blending mode.
love_graphics_setBlendMode :: (mode: *u8) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "setBlendMode");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushstring(L, mode);
	lua.call(L, 1, 0);
}
// Sets the blending mode.
love_graphics_setBlendMode :: (mode: *u8, alphamode: *u8) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "setBlendMode");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushstring(L, mode);
	lua.pushstring(L, alphamode);
	lua.call(L, 2, 0);
}
// Captures drawing operations to a Canvas.
love_graphics_setCanvas :: (canvas: Canvas, mipmap: lua.Number) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "setCanvas");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.rawgeti(L, lua.LUA_REGISTRYINDEX, xx canvas);
	lua.pushnumber(L, mipmap);
	lua.call(L, 2, 0);
}
// Captures drawing operations to a Canvas.
love_graphics_setCanvas :: () #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "setCanvas");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.call(L, 0, 0);
}
// Captures drawing operations to a Canvas.
love_graphics_setCanvas :: (canvas1: Canvas, canvas2: Canvas) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "setCanvas");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.rawgeti(L, lua.LUA_REGISTRYINDEX, xx canvas1);
	lua.rawgeti(L, lua.LUA_REGISTRYINDEX, xx canvas2);
	lua.call(L, 2, 0);
}
// Captures drawing operations to a Canvas.
love_graphics_setCanvas :: (canvas: Canvas, slice: lua.Number, mipmap: lua.Number) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "setCanvas");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.rawgeti(L, lua.LUA_REGISTRYINDEX, xx canvas);
	lua.pushnumber(L, slice);
	lua.pushnumber(L, mipmap);
	lua.call(L, 3, 0);
}
// Captures drawing operations to a Canvas.
love_graphics_setCanvas :: (setup: lua.Table) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "setCanvas");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.createtable(L, 0, 0);
	lua.call(L, 1, 0);
}
// Sets the color used for drawing.
love_graphics_setColor :: (red: lua.Number, green: lua.Number, blue: lua.Number, alpha: lua.Number) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "setColor");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushnumber(L, red);
	lua.pushnumber(L, green);
	lua.pushnumber(L, blue);
	lua.pushnumber(L, alpha);
	lua.call(L, 4, 0);
}
// Sets the color used for drawing.
love_graphics_setColor :: (rgba: lua.Table) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "setColor");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.createtable(L, 0, 0);
	lua.call(L, 1, 0);
}
// Sets the color mask. Enables or disables specific color components when rendering and clearing the screen. For example, if '''red''' is set to '''false''', no further changes will be made to the red component of any pixels.
love_graphics_setColorMask :: (red: s32, green: s32, blue: s32, alpha: s32) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "setColorMask");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushboolean(L, red);
	lua.pushboolean(L, green);
	lua.pushboolean(L, blue);
	lua.pushboolean(L, alpha);
	lua.call(L, 4, 0);
}
// Sets the color mask. Enables or disables specific color components when rendering and clearing the screen. For example, if '''red''' is set to '''false''', no further changes will be made to the red component of any pixels.
love_graphics_setColorMask :: () #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "setColorMask");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.call(L, 0, 0);
}
// Sets the default scaling filters used with Images, Canvases, and Fonts.
love_graphics_setDefaultFilter :: (min: *u8, mag: *u8, anisotropy: lua.Number) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "setDefaultFilter");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushstring(L, min);
	lua.pushstring(L, mag);
	lua.pushnumber(L, anisotropy);
	lua.call(L, 3, 0);
}
// Configures depth testing and writing to the depth buffer.
love_graphics_setDepthMode :: (comparemode: *u8, write: s32) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "setDepthMode");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushstring(L, comparemode);
	lua.pushboolean(L, write);
	lua.call(L, 2, 0);
}
// Configures depth testing and writing to the depth buffer.
love_graphics_setDepthMode :: () #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "setDepthMode");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.call(L, 0, 0);
}
// Set an already-loaded Font as the current font or create and load a new one from the file and size.
love_graphics_setFont :: (font: Font) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "setFont");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.rawgeti(L, lua.LUA_REGISTRYINDEX, xx font);
	lua.call(L, 1, 0);
}
// Sets whether triangles with clockwise- or counterclockwise-ordered vertices are considered front-facing.
love_graphics_setFrontFaceWinding :: (winding: *u8) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "setFrontFaceWinding");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushstring(L, winding);
	lua.call(L, 1, 0);
}
// Sets the line join style. See LineJoin for the possible options.
love_graphics_setLineJoin :: (join: *u8) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "setLineJoin");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushstring(L, join);
	lua.call(L, 1, 0);
}
// Sets the line style.
love_graphics_setLineStyle :: (style: *u8) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "setLineStyle");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushstring(L, style);
	lua.call(L, 1, 0);
}
// Sets the line width.
love_graphics_setLineWidth :: (width: lua.Number) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "setLineWidth");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushnumber(L, width);
	lua.call(L, 1, 0);
}
// Sets whether back-facing triangles in a Mesh are culled.
love_graphics_setMeshCullMode :: (mode: *u8) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "setMeshCullMode");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushstring(L, mode);
	lua.call(L, 1, 0);
}
// Creates and sets a new Font.
love_graphics_setNewFont :: (size: lua.Number) -> (font: Font) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "setNewFont");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushnumber(L, size);
	lua.call(L, 1, 1);

	return xx lua.luaL_ref(L, lua.LUA_REGISTRYINDEX);
}
// Creates and sets a new Font.
love_graphics_setNewFont :: (filename: *u8, size: lua.Number) -> (font: Font) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "setNewFont");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushstring(L, filename);
	lua.pushnumber(L, size);
	lua.call(L, 2, 1);

	return xx lua.luaL_ref(L, lua.LUA_REGISTRYINDEX);
}
// Creates and sets a new Font.
love_graphics_setNewFont :: (file: File, size: lua.Number) -> (font: Font) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "setNewFont");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.rawgeti(L, lua.LUA_REGISTRYINDEX, xx file);
	lua.pushnumber(L, size);
	lua.call(L, 2, 1);

	return xx lua.luaL_ref(L, lua.LUA_REGISTRYINDEX);
}
// Creates and sets a new Font.
love_graphics_setNewFont :: (data: Data, size: lua.Number) -> (font: Font) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "setNewFont");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.rawgeti(L, lua.LUA_REGISTRYINDEX, xx data);
	lua.pushnumber(L, size);
	lua.call(L, 2, 1);

	return xx lua.luaL_ref(L, lua.LUA_REGISTRYINDEX);
}
// Creates and sets a new Font.
love_graphics_setNewFont :: (rasterizer: Rasterizer) -> (font: Font) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "setNewFont");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.rawgeti(L, lua.LUA_REGISTRYINDEX, xx rasterizer);
	lua.call(L, 1, 1);

	return xx lua.luaL_ref(L, lua.LUA_REGISTRYINDEX);
}
// Sets the point size.
love_graphics_setPointSize :: (size: lua.Number) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "setPointSize");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushnumber(L, size);
	lua.call(L, 1, 0);
}
// Sets or disables scissor.
love_graphics_setScissor :: (x: lua.Number, y: lua.Number, width: lua.Number, height: lua.Number) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "setScissor");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushnumber(L, x);
	lua.pushnumber(L, y);
	lua.pushnumber(L, width);
	lua.pushnumber(L, height);
	lua.call(L, 4, 0);
}
// Sets or disables scissor.
love_graphics_setScissor :: () #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "setScissor");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.call(L, 0, 0);
}
// Sets or resets a Shader as the current pixel effect or vertex shaders. All drawing operations until the next ''love.graphics.setShader'' will be drawn using the Shader object specified.
love_graphics_setShader :: (shader: Shader) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "setShader");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.rawgeti(L, lua.LUA_REGISTRYINDEX, xx shader);
	lua.call(L, 1, 0);
}
// Sets or resets a Shader as the current pixel effect or vertex shaders. All drawing operations until the next ''love.graphics.setShader'' will be drawn using the Shader object specified.
love_graphics_setShader :: () #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "setShader");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.call(L, 0, 0);
}
// Configures or disables stencil testing.
love_graphics_setStencilTest :: (comparemode: *u8, comparevalue: lua.Number) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "setStencilTest");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushstring(L, comparemode);
	lua.pushnumber(L, comparevalue);
	lua.call(L, 2, 0);
}
// Configures or disables stencil testing.
love_graphics_setStencilTest :: () #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "setStencilTest");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.call(L, 0, 0);
}
// Sets whether wireframe lines will be used when drawing.
love_graphics_setWireframe :: (enable: s32) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "setWireframe");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushboolean(L, enable);
	lua.call(L, 1, 0);
}
// Shears the coordinate system.
love_graphics_shear :: (kx: lua.Number, ky: lua.Number) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "shear");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushnumber(L, kx);
	lua.pushnumber(L, ky);
	lua.call(L, 2, 0);
}
// Draws geometry as a stencil.
love_graphics_stencil :: (stencilfunction: *void, action: *u8, value: lua.Number, keepvalues: s32) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "stencil");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushcclosure(L, stencilfunction, 0);
	lua.pushstring(L, action);
	lua.pushnumber(L, value);
	lua.pushboolean(L, keepvalues);
	lua.call(L, 4, 0);
}
// Converts the given 2D position from global coordinates into screen-space.
love_graphics_transformPoint :: (globalx: lua.Number, globaly: lua.Number) -> struct { _screenx: lua.Number; _screeny: lua.Number; } #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "transformPoint");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushnumber(L, globalx);
	lua.pushnumber(L, globaly);
	lua.call(L, 2, 2);

	return .{ _screenx = lua.tonumber(L, -2), _screeny = lua.tonumber(L, -1) };
}
// Translates the coordinate system in two dimensions.
love_graphics_translate :: (dx: lua.Number, dy: lua.Number) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "translate");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushnumber(L, dx);
	lua.pushnumber(L, dy);
	lua.call(L, 2, 0);
}
// Validates shader code. Check if specified shader code does not contain any errors.
love_graphics_validateShader :: (gles: s32, code: *u8) -> struct { _status: s32; _message: *u8; } #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "validateShader");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushboolean(L, gles);
	lua.pushstring(L, code);
	lua.call(L, 2, 2);

	return .{ _status = lua.toboolean(L, -2), _message = lua.tolstring(L, -1, null) };
}
// Validates shader code. Check if specified shader code does not contain any errors.
love_graphics_validateShader :: (gles: s32, pixelcode: *u8, vertexcode: *u8) -> struct { _status: s32; _message: *u8; } #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "graphics");
	lua.getfield(L, -1, "validateShader");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushboolean(L, gles);
	lua.pushstring(L, pixelcode);
	lua.pushstring(L, vertexcode);
	lua.call(L, 3, 2);

	return .{ _status = lua.toboolean(L, -2), _message = lua.tolstring(L, -1, null) };
}
