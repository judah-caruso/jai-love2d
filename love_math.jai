// This file was generated by generate_bindings.lua

BezierCurve :: #type,distinct lua.Ref;
RandomGenerator :: #type,distinct lua.Ref;
Transform :: #type,distinct lua.Ref;

MatrixLayout :: enum {
	Row; // row
	Column; // column
}
MatrixLayoutMap :: string.[ "row", "column" ];


// Converts a color from 0..255 to 0..1 range.
love_math_colorFromBytes :: (rb: lua.Number, gb: lua.Number, bb: lua.Number, ab: lua.Number) -> struct { _r: lua.Number; _g: lua.Number; _b: lua.Number; _a: lua.Number; } #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "math");
	lua.getfield(L, -1, "colorFromBytes");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushnumber(L, rb);
	lua.pushnumber(L, gb);
	lua.pushnumber(L, bb);
	lua.pushnumber(L, ab);
	lua.call(L, 4, 4);

	return .{ _r = lua.tonumber(L, -4), _g = lua.tonumber(L, -3), _b = lua.tonumber(L, -2), _a = lua.tonumber(L, -1) };
}
// Converts a color from 0..1 to 0..255 range.
love_math_colorToBytes :: (r: lua.Number, g: lua.Number, b: lua.Number, a: lua.Number) -> struct { _rb: lua.Number; _gb: lua.Number; _bb: lua.Number; _ab: lua.Number; } #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "math");
	lua.getfield(L, -1, "colorToBytes");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushnumber(L, r);
	lua.pushnumber(L, g);
	lua.pushnumber(L, b);
	lua.pushnumber(L, a);
	lua.call(L, 4, 4);

	return .{ _rb = lua.tonumber(L, -4), _gb = lua.tonumber(L, -3), _bb = lua.tonumber(L, -2), _ab = lua.tonumber(L, -1) };
}
// Compresses a string or data using a specific compression algorithm.
love_math_compress :: (rawstring: *u8, format: *u8, level: lua.Number) -> (compresseddata: CompressedData) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "math");
	lua.getfield(L, -1, "compress");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushstring(L, rawstring);
	lua.pushstring(L, format);
	lua.pushnumber(L, level);
	lua.call(L, 3, 1);

	return xx lua.luaL_ref(L, lua.LUA_REGISTRYINDEX);
}
// Compresses a string or data using a specific compression algorithm.
love_math_compress :: (data: Data, format: *u8, level: lua.Number) -> (compresseddata: CompressedData) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "math");
	lua.getfield(L, -1, "compress");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.rawgeti(L, lua.LUA_REGISTRYINDEX, xx data);
	lua.pushstring(L, format);
	lua.pushnumber(L, level);
	lua.call(L, 3, 1);

	return xx lua.luaL_ref(L, lua.LUA_REGISTRYINDEX);
}
// Decompresses a CompressedData or previously compressed string or Data object.
love_math_decompress :: (compresseddata: CompressedData) -> (rawstring: *u8) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "math");
	lua.getfield(L, -1, "decompress");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.rawgeti(L, lua.LUA_REGISTRYINDEX, xx compresseddata);
	lua.call(L, 1, 1);

	return lua.tolstring(L, -1, null);
}
// Decompresses a CompressedData or previously compressed string or Data object.
love_math_decompress :: (compressedstring: *u8, format: *u8) -> (rawstring: *u8) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "math");
	lua.getfield(L, -1, "decompress");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushstring(L, compressedstring);
	lua.pushstring(L, format);
	lua.call(L, 2, 1);

	return lua.tolstring(L, -1, null);
}
// Decompresses a CompressedData or previously compressed string or Data object.
love_math_decompress :: (data: Data, format: *u8) -> (rawstring: *u8) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "math");
	lua.getfield(L, -1, "decompress");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.rawgeti(L, lua.LUA_REGISTRYINDEX, xx data);
	lua.pushstring(L, format);
	lua.call(L, 2, 1);

	return lua.tolstring(L, -1, null);
}
// Converts a color from gamma-space (sRGB) to linear-space (RGB). This is useful when doing gamma-correct rendering and you need to do math in linear RGB in the few cases where LÖVE doesn't handle conversions automatically.
love_math_gammaToLinear :: (r: lua.Number, g: lua.Number, b: lua.Number) -> struct { _lr: lua.Number; _lg: lua.Number; _lb: lua.Number; } #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "math");
	lua.getfield(L, -1, "gammaToLinear");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushnumber(L, r);
	lua.pushnumber(L, g);
	lua.pushnumber(L, b);
	lua.call(L, 3, 3);

	return .{ _lr = lua.tonumber(L, -3), _lg = lua.tonumber(L, -2), _lb = lua.tonumber(L, -1) };
}
// Converts a color from gamma-space (sRGB) to linear-space (RGB). This is useful when doing gamma-correct rendering and you need to do math in linear RGB in the few cases where LÖVE doesn't handle conversions automatically.
love_math_gammaToLinear :: (color: lua.Table) -> struct { _lr: lua.Number; _lg: lua.Number; _lb: lua.Number; } #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "math");
	lua.getfield(L, -1, "gammaToLinear");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.createtable(L, 0, 0);
	lua.call(L, 1, 3);

	return .{ _lr = lua.tonumber(L, -3), _lg = lua.tonumber(L, -2), _lb = lua.tonumber(L, -1) };
}
// Converts a color from gamma-space (sRGB) to linear-space (RGB). This is useful when doing gamma-correct rendering and you need to do math in linear RGB in the few cases where LÖVE doesn't handle conversions automatically.
love_math_gammaToLinear :: (c: lua.Number) -> (lc: lua.Number) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "math");
	lua.getfield(L, -1, "gammaToLinear");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushnumber(L, c);
	lua.call(L, 1, 1);

	return lua.tonumber(L, -1);
}
// Gets the seed of the random number generator.
love_math_getRandomSeed :: () -> struct { _low: lua.Number; _high: lua.Number; } #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "math");
	lua.getfield(L, -1, "getRandomSeed");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.call(L, 0, 2);

	return .{ _low = lua.tonumber(L, -2), _high = lua.tonumber(L, -1) };
}
// Gets the current state of the random number generator. This returns an opaque implementation-dependent string which is only useful for later use with love.math.setRandomState or RandomGenerator:setState.
love_math_getRandomState :: () -> (state: *u8) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "math");
	lua.getfield(L, -1, "getRandomState");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.call(L, 0, 1);

	return lua.tolstring(L, -1, null);
}
// Checks whether a polygon is convex.
love_math_isConvex :: (vertices: lua.Table) -> (convex: s32) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "math");
	lua.getfield(L, -1, "isConvex");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.createtable(L, 0, 0);
	lua.call(L, 1, 1);

	return lua.toboolean(L, -1);
}
// Checks whether a polygon is convex.
love_math_isConvex :: (x1: lua.Number, y1: lua.Number, x2: lua.Number, y2: lua.Number, x3: lua.Number, y3: lua.Number) -> (convex: s32) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "math");
	lua.getfield(L, -1, "isConvex");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushnumber(L, x1);
	lua.pushnumber(L, y1);
	lua.pushnumber(L, x2);
	lua.pushnumber(L, y2);
	lua.pushnumber(L, x3);
	lua.pushnumber(L, y3);
	lua.call(L, 6, 1);

	return lua.toboolean(L, -1);
}
// Converts a color from linear-space (RGB) to gamma-space (sRGB). This is useful when storing linear RGB color values in an image, because the linear RGB color space has less precision than sRGB for dark colors, which can result in noticeable color banding when drawing.
love_math_linearToGamma :: (lr: lua.Number, lg: lua.Number, lb: lua.Number) -> struct { _cr: lua.Number; _cg: lua.Number; _cb: lua.Number; } #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "math");
	lua.getfield(L, -1, "linearToGamma");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushnumber(L, lr);
	lua.pushnumber(L, lg);
	lua.pushnumber(L, lb);
	lua.call(L, 3, 3);

	return .{ _cr = lua.tonumber(L, -3), _cg = lua.tonumber(L, -2), _cb = lua.tonumber(L, -1) };
}
// Converts a color from linear-space (RGB) to gamma-space (sRGB). This is useful when storing linear RGB color values in an image, because the linear RGB color space has less precision than sRGB for dark colors, which can result in noticeable color banding when drawing.
love_math_linearToGamma :: (color: lua.Table) -> struct { _cr: lua.Number; _cg: lua.Number; _cb: lua.Number; } #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "math");
	lua.getfield(L, -1, "linearToGamma");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.createtable(L, 0, 0);
	lua.call(L, 1, 3);

	return .{ _cr = lua.tonumber(L, -3), _cg = lua.tonumber(L, -2), _cb = lua.tonumber(L, -1) };
}
// Converts a color from linear-space (RGB) to gamma-space (sRGB). This is useful when storing linear RGB color values in an image, because the linear RGB color space has less precision than sRGB for dark colors, which can result in noticeable color banding when drawing.
love_math_linearToGamma :: (lc: lua.Number) -> (c: lua.Number) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "math");
	lua.getfield(L, -1, "linearToGamma");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushnumber(L, lc);
	lua.call(L, 1, 1);

	return lua.tonumber(L, -1);
}
// Creates a new BezierCurve object.
love_math_newBezierCurve :: (vertices: lua.Table) -> (curve: BezierCurve) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "math");
	lua.getfield(L, -1, "newBezierCurve");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.createtable(L, 0, 0);
	lua.call(L, 1, 1);

	return xx lua.luaL_ref(L, lua.LUA_REGISTRYINDEX);
}
// Creates a new BezierCurve object.
love_math_newBezierCurve :: (x1: lua.Number, y1: lua.Number, x2: lua.Number, y2: lua.Number, x3: lua.Number, y3: lua.Number) -> (curve: BezierCurve) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "math");
	lua.getfield(L, -1, "newBezierCurve");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushnumber(L, x1);
	lua.pushnumber(L, y1);
	lua.pushnumber(L, x2);
	lua.pushnumber(L, y2);
	lua.pushnumber(L, x3);
	lua.pushnumber(L, y3);
	lua.call(L, 6, 1);

	return xx lua.luaL_ref(L, lua.LUA_REGISTRYINDEX);
}
// Creates a new RandomGenerator object which is completely independent of other RandomGenerator objects and random functions.
love_math_newRandomGenerator :: () -> (rng: RandomGenerator) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "math");
	lua.getfield(L, -1, "newRandomGenerator");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.call(L, 0, 1);

	return xx lua.luaL_ref(L, lua.LUA_REGISTRYINDEX);
}
// Creates a new RandomGenerator object which is completely independent of other RandomGenerator objects and random functions.
love_math_newRandomGenerator :: (seed: lua.Number) -> (rng: RandomGenerator) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "math");
	lua.getfield(L, -1, "newRandomGenerator");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushnumber(L, seed);
	lua.call(L, 1, 1);

	return xx lua.luaL_ref(L, lua.LUA_REGISTRYINDEX);
}
// Creates a new RandomGenerator object which is completely independent of other RandomGenerator objects and random functions.
love_math_newRandomGenerator :: (low: lua.Number, high: lua.Number) -> (rng: RandomGenerator) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "math");
	lua.getfield(L, -1, "newRandomGenerator");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushnumber(L, low);
	lua.pushnumber(L, high);
	lua.call(L, 2, 1);

	return xx lua.luaL_ref(L, lua.LUA_REGISTRYINDEX);
}
// Creates a new Transform object.
love_math_newTransform :: () -> (transform: Transform) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "math");
	lua.getfield(L, -1, "newTransform");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.call(L, 0, 1);

	return xx lua.luaL_ref(L, lua.LUA_REGISTRYINDEX);
}
// Creates a new Transform object.
love_math_newTransform :: (x: lua.Number, y: lua.Number, angle: lua.Number, sx: lua.Number, sy: lua.Number, ox: lua.Number, oy: lua.Number, kx: lua.Number, ky: lua.Number) -> (transform: Transform) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "math");
	lua.getfield(L, -1, "newTransform");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushnumber(L, x);
	lua.pushnumber(L, y);
	lua.pushnumber(L, angle);
	lua.pushnumber(L, sx);
	lua.pushnumber(L, sy);
	lua.pushnumber(L, ox);
	lua.pushnumber(L, oy);
	lua.pushnumber(L, kx);
	lua.pushnumber(L, ky);
	lua.call(L, 9, 1);

	return xx lua.luaL_ref(L, lua.LUA_REGISTRYINDEX);
}
// Generates a Simplex or Perlin noise value in 1-4 dimensions. The return value will always be the same, given the same arguments.
love_math_noise :: (x: lua.Number) -> (value: lua.Number) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "math");
	lua.getfield(L, -1, "noise");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushnumber(L, x);
	lua.call(L, 1, 1);

	return lua.tonumber(L, -1);
}
// Generates a Simplex or Perlin noise value in 1-4 dimensions. The return value will always be the same, given the same arguments.
love_math_noise :: (x: lua.Number, y: lua.Number) -> (value: lua.Number) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "math");
	lua.getfield(L, -1, "noise");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushnumber(L, x);
	lua.pushnumber(L, y);
	lua.call(L, 2, 1);

	return lua.tonumber(L, -1);
}
// Generates a Simplex or Perlin noise value in 1-4 dimensions. The return value will always be the same, given the same arguments.
love_math_noise :: (x: lua.Number, y: lua.Number, z: lua.Number) -> (value: lua.Number) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "math");
	lua.getfield(L, -1, "noise");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushnumber(L, x);
	lua.pushnumber(L, y);
	lua.pushnumber(L, z);
	lua.call(L, 3, 1);

	return lua.tonumber(L, -1);
}
// Generates a Simplex or Perlin noise value in 1-4 dimensions. The return value will always be the same, given the same arguments.
love_math_noise :: (x: lua.Number, y: lua.Number, z: lua.Number, w: lua.Number) -> (value: lua.Number) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "math");
	lua.getfield(L, -1, "noise");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushnumber(L, x);
	lua.pushnumber(L, y);
	lua.pushnumber(L, z);
	lua.pushnumber(L, w);
	lua.call(L, 4, 1);

	return lua.tonumber(L, -1);
}
// Generates a pseudo-random number in a platform independent manner. The default love.run seeds this function at startup, so you generally don't need to seed it yourself.
love_math_random :: () -> (number: lua.Number) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "math");
	lua.getfield(L, -1, "random");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.call(L, 0, 1);

	return lua.tonumber(L, -1);
}
// Generates a pseudo-random number in a platform independent manner. The default love.run seeds this function at startup, so you generally don't need to seed it yourself.
love_math_random :: (max: lua.Number) -> (number: lua.Number) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "math");
	lua.getfield(L, -1, "random");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushnumber(L, max);
	lua.call(L, 1, 1);

	return lua.tonumber(L, -1);
}
// Generates a pseudo-random number in a platform independent manner. The default love.run seeds this function at startup, so you generally don't need to seed it yourself.
love_math_random :: (min: lua.Number, max: lua.Number) -> (number: lua.Number) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "math");
	lua.getfield(L, -1, "random");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushnumber(L, min);
	lua.pushnumber(L, max);
	lua.call(L, 2, 1);

	return lua.tonumber(L, -1);
}
// Get a normally distributed pseudo random number.
love_math_randomNormal :: (stddev: lua.Number, mean: lua.Number) -> (number: lua.Number) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "math");
	lua.getfield(L, -1, "randomNormal");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushnumber(L, stddev);
	lua.pushnumber(L, mean);
	lua.call(L, 2, 1);

	return lua.tonumber(L, -1);
}
// Sets the seed of the random number generator using the specified integer number. This is called internally at startup, so you generally don't need to call it yourself.
love_math_setRandomSeed :: (seed: lua.Number) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "math");
	lua.getfield(L, -1, "setRandomSeed");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushnumber(L, seed);
	lua.call(L, 1, 0);
}
// Sets the seed of the random number generator using the specified integer number. This is called internally at startup, so you generally don't need to call it yourself.
love_math_setRandomSeed :: (low: lua.Number, high: lua.Number) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "math");
	lua.getfield(L, -1, "setRandomSeed");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushnumber(L, low);
	lua.pushnumber(L, high);
	lua.call(L, 2, 0);
}
// Sets the current state of the random number generator. The value used as an argument for this function is an opaque implementation-dependent string and should only originate from a previous call to love.math.getRandomState.
love_math_setRandomState :: (state: *u8) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "math");
	lua.getfield(L, -1, "setRandomState");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushstring(L, state);
	lua.call(L, 1, 0);
}
// Decomposes a simple convex or concave polygon into triangles.
love_math_triangulate :: (polygon: lua.Table) -> (triangles: lua.Table) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "math");
	lua.getfield(L, -1, "triangulate");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.createtable(L, 0, 0);
	lua.call(L, 1, 1);

	return xx lua.luaL_ref(L, lua.LUA_REGISTRYINDEX);
}
// Decomposes a simple convex or concave polygon into triangles.
love_math_triangulate :: (x1: lua.Number, y1: lua.Number, x2: lua.Number, y2: lua.Number, x3: lua.Number, y3: lua.Number) -> (triangles: lua.Table) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "math");
	lua.getfield(L, -1, "triangulate");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushnumber(L, x1);
	lua.pushnumber(L, y1);
	lua.pushnumber(L, x2);
	lua.pushnumber(L, y2);
	lua.pushnumber(L, x3);
	lua.pushnumber(L, y3);
	lua.call(L, 6, 1);

	return xx lua.luaL_ref(L, lua.LUA_REGISTRYINDEX);
}
