// This file was generated by generate_bindings.lua

DroppedFile :: #type,distinct lua.Ref;
File :: #type,distinct lua.Ref;
FileData :: #type,distinct lua.Ref;

BufferMode :: enum {
	None; // none
	Line; // line
	Full; // full
}
BufferModeMap :: string.[ "none", "line", "full" ];

FileDecoder :: enum {
	File; // file
	Base64; // base64
}
FileDecoderMap :: string.[ "file", "base64" ];

FileMode :: enum {
	R; // r
	W; // w
	A; // a
	C; // c
}
FileModeMap :: string.[ "r", "w", "a", "c" ];

FileType :: enum {
	File; // file
	Directory; // directory
	Symlink; // symlink
	Other; // other
}
FileTypeMap :: string.[ "file", "directory", "symlink", "other" ];


// Append data to an existing file.
love_filesystem_append :: (name: *u8, data: *u8, size: lua.Number) -> struct { _success: s32; _errormsg: *u8; } #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "filesystem");
	lua.getfield(L, -1, "append");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushstring(L, name);
	lua.pushstring(L, data);
	lua.pushnumber(L, size);
	lua.call(L, 3, 2);

	return .{ _success = lua.toboolean(L, -2), _errormsg = lua.tolstring(L, -1, null) };
}
// Append data to an existing file.
love_filesystem_append :: (name: *u8, data: Data, size: lua.Number) -> struct { _success: s32; _errormsg: *u8; } #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "filesystem");
	lua.getfield(L, -1, "append");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushstring(L, name);
	lua.rawgeti(L, lua.LUA_REGISTRYINDEX, xx data);
	lua.pushnumber(L, size);
	lua.call(L, 3, 2);

	return .{ _success = lua.toboolean(L, -2), _errormsg = lua.tolstring(L, -1, null) };
}
// Gets whether love.filesystem follows symbolic links.
love_filesystem_areSymlinksEnabled :: () -> (enable: s32) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "filesystem");
	lua.getfield(L, -1, "areSymlinksEnabled");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.call(L, 0, 1);

	return lua.toboolean(L, -1);
}
// Recursively creates a directory.
love_filesystem_createDirectory :: (name: *u8) -> (success: s32) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "filesystem");
	lua.getfield(L, -1, "createDirectory");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushstring(L, name);
	lua.call(L, 1, 1);

	return lua.toboolean(L, -1);
}
// Returns the application data directory (could be the same as getUserDirectory)
love_filesystem_getAppdataDirectory :: () -> (path: *u8) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "filesystem");
	lua.getfield(L, -1, "getAppdataDirectory");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.call(L, 0, 1);

	return lua.tolstring(L, -1, null);
}
// Gets the filesystem paths that will be searched for c libraries when require is called.
love_filesystem_getCRequirePath :: () -> (paths: *u8) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "filesystem");
	lua.getfield(L, -1, "getCRequirePath");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.call(L, 0, 1);

	return lua.tolstring(L, -1, null);
}
// Returns a table with the names of files and subdirectories in the specified path. The table is not sorted in any way; the order is undefined.
love_filesystem_getDirectoryItems :: (dir: *u8) -> (files: lua.Table) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "filesystem");
	lua.getfield(L, -1, "getDirectoryItems");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushstring(L, dir);
	lua.call(L, 1, 1);

	return xx lua.luaL_ref(L, lua.LUA_REGISTRYINDEX);
}
// Returns a table with the names of files and subdirectories in the specified path. The table is not sorted in any way; the order is undefined.
love_filesystem_getDirectoryItems :: (dir: *u8, callback: *void) -> (files: lua.Table) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "filesystem");
	lua.getfield(L, -1, "getDirectoryItems");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushstring(L, dir);
	lua.pushcclosure(L, callback, 0);
	lua.call(L, 2, 1);

	return xx lua.luaL_ref(L, lua.LUA_REGISTRYINDEX);
}
// Gets the write directory name for your game. 
love_filesystem_getIdentity :: () -> (name: *u8) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "filesystem");
	lua.getfield(L, -1, "getIdentity");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.call(L, 0, 1);

	return lua.tolstring(L, -1, null);
}
// Gets information about the specified file or directory.
love_filesystem_getInfo :: (path: *u8, filtertype: *u8) -> (info: lua.Table) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "filesystem");
	lua.getfield(L, -1, "getInfo");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushstring(L, path);
	lua.pushstring(L, filtertype);
	lua.call(L, 2, 1);

	return xx lua.luaL_ref(L, lua.LUA_REGISTRYINDEX);
}
// Gets information about the specified file or directory.
love_filesystem_getInfo :: (path: *u8, info: lua.Table) -> (info: lua.Table) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "filesystem");
	lua.getfield(L, -1, "getInfo");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushstring(L, path);
	lua.createtable(L, 0, 0);
	lua.call(L, 2, 1);

	return xx lua.luaL_ref(L, lua.LUA_REGISTRYINDEX);
}
// Gets information about the specified file or directory.
love_filesystem_getInfo :: (path: *u8, filtertype: *u8, info: lua.Table) -> (info: lua.Table) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "filesystem");
	lua.getfield(L, -1, "getInfo");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushstring(L, path);
	lua.pushstring(L, filtertype);
	lua.createtable(L, 0, 0);
	lua.call(L, 3, 1);

	return xx lua.luaL_ref(L, lua.LUA_REGISTRYINDEX);
}
// Gets the platform-specific absolute path of the directory containing a filepath.
love_filesystem_getRealDirectory :: (filepath: *u8) -> (realdir: *u8) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "filesystem");
	lua.getfield(L, -1, "getRealDirectory");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushstring(L, filepath);
	lua.call(L, 1, 1);

	return lua.tolstring(L, -1, null);
}
// Gets the filesystem paths that will be searched when require is called.
love_filesystem_getRequirePath :: () -> (paths: *u8) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "filesystem");
	lua.getfield(L, -1, "getRequirePath");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.call(L, 0, 1);

	return lua.tolstring(L, -1, null);
}
// Gets the full path to the designated save directory.
love_filesystem_getSaveDirectory :: () -> (dir: *u8) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "filesystem");
	lua.getfield(L, -1, "getSaveDirectory");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.call(L, 0, 1);

	return lua.tolstring(L, -1, null);
}
// Returns the full path to the the .love file or directory. If the game is fused to the LÖVE executable, then the executable is returned.
love_filesystem_getSource :: () -> (path: *u8) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "filesystem");
	lua.getfield(L, -1, "getSource");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.call(L, 0, 1);

	return lua.tolstring(L, -1, null);
}
// Returns the full path to the directory containing the .love file. If the game is fused to the LÖVE executable, then the directory containing the executable is returned.
love_filesystem_getSourceBaseDirectory :: () -> (path: *u8) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "filesystem");
	lua.getfield(L, -1, "getSourceBaseDirectory");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.call(L, 0, 1);

	return lua.tolstring(L, -1, null);
}
// Returns the path of the user's directory
love_filesystem_getUserDirectory :: () -> (path: *u8) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "filesystem");
	lua.getfield(L, -1, "getUserDirectory");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.call(L, 0, 1);

	return lua.tolstring(L, -1, null);
}
// Gets the current working directory.
love_filesystem_getWorkingDirectory :: () -> (cwd: *u8) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "filesystem");
	lua.getfield(L, -1, "getWorkingDirectory");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.call(L, 0, 1);

	return lua.tolstring(L, -1, null);
}
// Initializes love.filesystem, will be called internally, so should not be used explicitly.
love_filesystem_init :: (appname: *u8) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "filesystem");
	lua.getfield(L, -1, "init");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushstring(L, appname);
	lua.call(L, 1, 0);
}
// Gets whether the game is in fused mode or not.
love_filesystem_isFused :: () -> (fused: s32) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "filesystem");
	lua.getfield(L, -1, "isFused");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.call(L, 0, 1);

	return lua.toboolean(L, -1);
}
// Iterate over the lines in a file.
love_filesystem_lines :: (name: *u8) -> (iterator: *void) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "filesystem");
	lua.getfield(L, -1, "lines");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushstring(L, name);
	lua.call(L, 1, 1);

	return xx lua.tocfunction(L, -1);
}
// Loads a Lua file (but does not run it).
love_filesystem_load :: (name: *u8) -> struct { _chunk: *void; _errormsg: *u8; } #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "filesystem");
	lua.getfield(L, -1, "load");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushstring(L, name);
	lua.call(L, 1, 2);

	return .{ _chunk = xx lua.tocfunction(L, -2), _errormsg = lua.tolstring(L, -1, null) };
}
// Mounts a zip file or folder in the game's save directory for reading.
love_filesystem_mount :: (archive: *u8, mountpoint: *u8, appendtopath: s32) -> (success: s32) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "filesystem");
	lua.getfield(L, -1, "mount");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushstring(L, archive);
	lua.pushstring(L, mountpoint);
	lua.pushboolean(L, appendtopath);
	lua.call(L, 3, 1);

	return lua.toboolean(L, -1);
}
// Mounts a zip file or folder in the game's save directory for reading.
love_filesystem_mount :: (filedata: FileData, mountpoint: *u8, appendtopath: s32) -> (success: s32) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "filesystem");
	lua.getfield(L, -1, "mount");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.rawgeti(L, lua.LUA_REGISTRYINDEX, xx filedata);
	lua.pushstring(L, mountpoint);
	lua.pushboolean(L, appendtopath);
	lua.call(L, 3, 1);

	return lua.toboolean(L, -1);
}
// Mounts a zip file or folder in the game's save directory for reading.
love_filesystem_mount :: (data: Data, archivename: *u8, mountpoint: *u8, appendtopath: s32) -> (success: s32) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "filesystem");
	lua.getfield(L, -1, "mount");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.rawgeti(L, lua.LUA_REGISTRYINDEX, xx data);
	lua.pushstring(L, archivename);
	lua.pushstring(L, mountpoint);
	lua.pushboolean(L, appendtopath);
	lua.call(L, 4, 1);

	return lua.toboolean(L, -1);
}
// Creates a new File object. 
love_filesystem_newFile :: (filename: *u8) -> (file: File) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "filesystem");
	lua.getfield(L, -1, "newFile");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushstring(L, filename);
	lua.call(L, 1, 1);

	return xx lua.luaL_ref(L, lua.LUA_REGISTRYINDEX);
}
// Creates a new File object. 
love_filesystem_newFile :: (filename: *u8, mode: *u8) -> struct { _file: File; _errorstr: *u8; } #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "filesystem");
	lua.getfield(L, -1, "newFile");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushstring(L, filename);
	lua.pushstring(L, mode);
	lua.call(L, 2, 2);

	return .{ _file = xx lua.luaL_ref(L, lua.LUA_REGISTRYINDEX), _errorstr = lua.tolstring(L, -1, null) };
}
// Creates a new FileData object from a file on disk, or from a string in memory.
love_filesystem_newFileData :: (contents: *u8, name: *u8) -> (data: FileData) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "filesystem");
	lua.getfield(L, -1, "newFileData");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushstring(L, contents);
	lua.pushstring(L, name);
	lua.call(L, 2, 1);

	return xx lua.luaL_ref(L, lua.LUA_REGISTRYINDEX);
}
// Creates a new FileData object from a file on disk, or from a string in memory.
love_filesystem_newFileData :: (originaldata: Data, name: *u8) -> (data: FileData) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "filesystem");
	lua.getfield(L, -1, "newFileData");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.rawgeti(L, lua.LUA_REGISTRYINDEX, xx originaldata);
	lua.pushstring(L, name);
	lua.call(L, 2, 1);

	return xx lua.luaL_ref(L, lua.LUA_REGISTRYINDEX);
}
// Creates a new FileData object from a file on disk, or from a string in memory.
love_filesystem_newFileData :: (filepath: *u8) -> struct { _data: FileData; _err: *u8; } #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "filesystem");
	lua.getfield(L, -1, "newFileData");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushstring(L, filepath);
	lua.call(L, 1, 2);

	return .{ _data = xx lua.luaL_ref(L, lua.LUA_REGISTRYINDEX), _err = lua.tolstring(L, -1, null) };
}
// Read the contents of a file.
love_filesystem_read :: (name: *u8, size: lua.Number) -> struct { _contents: *u8; _size: lua.Number; } #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "filesystem");
	lua.getfield(L, -1, "read");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushstring(L, name);
	lua.pushnumber(L, size);
	lua.call(L, 2, 2);

	return .{ _contents = lua.tolstring(L, -2, null), _size = lua.tonumber(L, -1) };
}
// Read the contents of a file.
love_filesystem_read :: (container: *u8, name: *u8, size: lua.Number) -> struct { _contents: FileData; _size: lua.Number; } #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "filesystem");
	lua.getfield(L, -1, "read");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushstring(L, container);
	lua.pushstring(L, name);
	lua.pushnumber(L, size);
	lua.call(L, 3, 2);

	return .{ _contents = xx lua.luaL_ref(L, lua.LUA_REGISTRYINDEX), _size = lua.tonumber(L, -1) };
}
// Removes a file or empty directory.
love_filesystem_remove :: (name: *u8) -> (success: s32) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "filesystem");
	lua.getfield(L, -1, "remove");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushstring(L, name);
	lua.call(L, 1, 1);

	return lua.toboolean(L, -1);
}
// Sets the filesystem paths that will be searched for c libraries when require is called.
love_filesystem_setCRequirePath :: (paths: *u8) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "filesystem");
	lua.getfield(L, -1, "setCRequirePath");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushstring(L, paths);
	lua.call(L, 1, 0);
}
// Sets the write directory for your game. 
love_filesystem_setIdentity :: (name: *u8) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "filesystem");
	lua.getfield(L, -1, "setIdentity");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushstring(L, name);
	lua.call(L, 1, 0);
}
// Sets the write directory for your game. 
// Sets the filesystem paths that will be searched when require is called.
love_filesystem_setRequirePath :: (paths: *u8) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "filesystem");
	lua.getfield(L, -1, "setRequirePath");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushstring(L, paths);
	lua.call(L, 1, 0);
}
// Sets the source of the game, where the code is present. This function can only be called once, and is normally automatically done by LÖVE.
love_filesystem_setSource :: (path: *u8) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "filesystem");
	lua.getfield(L, -1, "setSource");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushstring(L, path);
	lua.call(L, 1, 0);
}
// Sets whether love.filesystem follows symbolic links. It is enabled by default in version 0.10.0 and newer, and disabled by default in 0.9.2.
love_filesystem_setSymlinksEnabled :: (enable: s32) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "filesystem");
	lua.getfield(L, -1, "setSymlinksEnabled");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushboolean(L, enable);
	lua.call(L, 1, 0);
}
// Unmounts a zip file or folder previously mounted for reading with love.filesystem.mount.
love_filesystem_unmount :: (archive: *u8) -> (success: s32) #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "filesystem");
	lua.getfield(L, -1, "unmount");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushstring(L, archive);
	lua.call(L, 1, 1);

	return lua.toboolean(L, -1);
}
// Write data to a file in the save directory. If the file existed already, it will be completely replaced by the new contents.
love_filesystem_write :: (name: *u8, data: *u8, size: lua.Number) -> struct { _success: s32; _message: *u8; } #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "filesystem");
	lua.getfield(L, -1, "write");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushstring(L, name);
	lua.pushstring(L, data);
	lua.pushnumber(L, size);
	lua.call(L, 3, 2);

	return .{ _success = lua.toboolean(L, -2), _message = lua.tolstring(L, -1, null) };
}
// Write data to a file in the save directory. If the file existed already, it will be completely replaced by the new contents.
love_filesystem_write :: (name: *u8, data: Data, size: lua.Number) -> struct { _success: s32; _message: *u8; } #no_context #c_call {
	lua.getfield(L, lua.LUA_GLOBALSINDEX, "love");
	lua.getfield(L, -1, "filesystem");
	lua.getfield(L, -1, "write");
	lua._remove(L, -3);
	lua._remove(L, -2);

	lua.pushstring(L, name);
	lua.rawgeti(L, lua.LUA_REGISTRYINDEX, xx data);
	lua.pushnumber(L, size);
	lua.call(L, 3, 2);

	return .{ _success = lua.toboolean(L, -2), _message = lua.tolstring(L, -1, null) };
}
